<!DOCTYPE html>
<html lang="es">
<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="">
  <meta name="author" content="">

  <title>Blog Personal - Unidad 2</title>

  <!-- Bootstrap core CSS -->
  <link href="vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">

  <!-- Custom fonts for this template -->
  <link href="https://fonts.googleapis.com/css?family=Saira+Extra+Condensed:500,700" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Muli:400,400i,800,800i" rel="stylesheet">
  <link href="vendor/fontawesome-free/css/all.min.css" rel="stylesheet">

  <!-- Custom styles for this template -->
  <link href="css/resume.min.css" rel="stylesheet">
  <link rel="icon" href="img/mifavicom.ico"/>
</head>

<body id="page-top">

  <nav class="navbar navbar-expand-lg navbar-dark bg-primary fixed-top" id="sideNav">
    <a class="navbar-brand js-scroll-trigger" href="#page-top">
      <span class="d-block d-lg-none">UNIDAD 1</span>
      <span class="d-none d-lg-block">
        <img class="img-fluid img-profile rounded-circle mx-auto mb-2" src="img/profile.jpg" alt="">
      </span>
    </a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav">
        <li class="nav-item">
          <a class="nav-link js-scroll-trigger" href="#about">Acerca de la Unidad</a>
        </li>
        <li class="nav-item">
          <a class="nav-link js-scroll-trigger" href="#themea">2.1 Proceso del software</a>
        </li>
        <li class="nav-item">
          <a class="nav-link js-scroll-trigger" href="#themeb">2.2 El ciclo de vida del Software</a>
        </li>
        <li class="nav-item">
          <a class="nav-link js-scroll-trigger" href="#themec">2.3 Modelos de desarrollo: tradicionales vs alternativos</a>
        </li>
        <li class="nav-item">
          <a class="nav-link js-scroll-trigger" href='index.html'>←Volver</a>
        </li>       
        </ul>
    </div>
  </nav>

  <div class="container-fluid p-0">

    <section class="resume-section p-3 p-lg-5 d-flex align-items-center" id="about">
      <div class="w-100">
        <h1 class="mb-0">PROCESO DE
          <span class="text-primary">DESARROLLO DE SOFTWARE</span>
        </h1>
        <div class="subheading mb-5">Unidad 2
        <p class="lead mb-5">Objetivo: Identificar el ciclo de vida del software a través de los estándares IEEE para diferenciar los modelos de desarrollo de software.</p>
              </div>
    </section>

    <section class="resume-section p-3 p-lg-5 d-flex align-items-center" id="themea">
      <div class="w-100">
        <h2 class="mb-5">2.1 Proceso del software</h2>
        <div class="resume-item d-flex flex-column flex-md-row justify-content-between mb-5">
          <div class="resume-content">
            <h3 class="mb-0">Definiciones</h3>
            <p>Conjunto de actividades necesarias para transformar las ideas iniciales del usuario, que desea automatizar un determinado trabajo, en software.​</p>
            <p>Conjunto ordenado de actividades; una serie de pasos que involucran tareas, restricciones y recursos que producen una determinada salida esperada.</p>
            <p>Marco de trabajo de las tareas que se requieren para construir software de alta calidad.</p>
            <p>Un	conjunto	estructurado	de	actividades	necesarias	para desarrollar un sistema de software.</p>
            <p>Muchos de los procesos de software son diferentes, pero todos implican:</p>
              <ul>
                <li>Especiﬁcación.</li>
                <li>Diseño e implementación.</li>
                <li>Validación.</li>
                <li>Evolución.</li>
              </ul>
            <p>Cualquier proceso tiene las siguientes características:</p>
                <ul>
                  <li>El proceso establece todas las actividades principales.</li>
                  <li>El proceso utiliza recursos, está sujeto a una serie de restricciones y genera productos intermedios y ﬁnales.</li>
                  <li>El proceso puede estar compuesto de subprocesos que se encadenan de alguna manera. Puede deﬁnirse como una  jerarquía de procesos organizada de modo que cada subproceso tenga su propio modelo de proceso</li>
                  <li>Cada actividad del proceso tiene criterios de entrada y de salida,  de modo que se conoce cuándo comienza y cuándo termina una actividad.</li>
                  <li>Las actividades se organizan en secuencia de modo que resulta claro cuando una actividad se realiza en orden relativo a otras actividades.</li>
                  <li>Todo  proceso tiene un conjunto  de principios orientadores que explican las metas de cada actividad.</li>
                  <li>Las restricciones o controles pueden aplicarse a una actividad, recurso o producto.</li>
                </ul>
              <h3 class="mb-0">Importancia</h3>  
              <p>Un proceso software debe especiﬁcar:</p>
              <ul>
                <li>La secuencia de actividades a realizar por el equipo de desarrollo.</li>
                <ul><li>Flujo de Actividades</li></lili></ul>
                <li>Los productos que deben crearse</li>
                <ul><li>Resultados del trabajo (modelos, documentos, datos informes...)</li><li>Qué y cuándo.</li></ul>
                <li>La asignación de tareas a cada miembro del equipo y al equipo como un todo.</li>
              </ul>
              <p>Los criterios para controlar el proceso</p>
              <ul>
                <li>Se establece el control de gestión de los proyectos software.</li>
                <li>Establecimiento de hitos.</li>
              </ul>
              <p>Las posibles heurísticas</p>
              <ul>
                <li>Facilita la gestión del proyecto</li>
                <li>Establece una división del trabajo</li>
                <li>Facilita la comunicación de los miembros del equipo</li>
                <li>Permite	la	reasignación	y	la	reutilización	de	personal especializado</li>
                <ul>
                  <li>Transferencia entre proyectos</li>
                </ul>
                <li>Mejora la productividad y el desarrollo</li>
                <ul><li>El desarrollo es reproducible</li></ul>
                <li>Establece el contexto en el que se aplican los métodos técnicos</li>
                <li>Gestiona el cambio adecuadamente</li>
                <li>Asegura la calidad</li>
              </ul>
              <h3 class="mb-0">Estándares relacionados con el proceso de Software</h3>
                <div class="subheading mb-3">Estándar ISO/IEC/IEEE 12207:2017</div>
                <p>El estándar ISO/IEC/IEEE 12207:2017 [ISO/IEC/IEEE, 2017] relativo a los procesos del ciclo de vida del software. Se aplica a la adquisición de sistemas de software, productos y servicios, al suministro, desarrollo, operación, mantenimiento y eliminación de productos de software o componentes de software de cualquier sistema, ya sea que se realice interna o externamente a una organización. Se incluyen aquellos aspectos de la deﬁnición del sistema necesarios para proporcionar el contexto de los productos y servicios de software. También proporciona procesos que pueden  emplearse  para deﬁnir, controlar y mejorar los procesos del ciclo de vida del software dentro de una organización o de un proyecto.</p>
                <p>Esta norma no fomenta o especiﬁca ningún modelo concreto de ciclo de vida, gestión del software o método de ingeniería, ni prescribe cómo realizar ninguna de las actividades.</p>
          </div>
        </div>

    <hr class="m-0">
    <hr class="m-0">

    <section class="resume-section p-3 p-lg-5 d-flex justify-content-center" id="themeb">
      <div class="w-100">
        <h2 class="mb-5">2.2 El ciclo de vida del Software</h2>
        <div class="resume-item d-flex flex-column flex-md-row justify-content-between mb-5">
          <div class="resume-content">
            <h3 class="mb-0">Definición y Etapas</h3>
            <div class="subheading mb-3">Definición</div>
            <p>Las distintas fases por las que pasa el software desde que nace una necesidad de mecanizar un proceso hasta que deja de utilizarse el software que sirvió para ese objetivo, pasando por las fases de desarrollo y explotación [Frakes et al., 1991]</p>
            <p>El período de tiempo que comienza cuando se concibe un producto software y ﬁnaliza cuando el producto pierde su utilidad. El ciclo de vida del software incluye las siguientes fases: fase de requisitos, fase de diseño, fase de realización, fase de pruebas, fase de instalación y aceptación, fase de operación y mantenimiento y, algunas veces, fase de retirada [AECC, 1986]</p>
            <p>Un	marco	de	referencia	que	contiene	los	procesos,	las actividades	y	las	tareas	involucradas	en	el	desarrollo,	la explotación y el mantenimiento de un producto de software, abarcando la vida del sistema desde la deﬁnición de requisitos hasta la ﬁnalización de su uso [ISO/IEC, 2008]</p>
            <p>Una aproximación lógica a la adquisición, el suministro, el desarrollo, la explotación y el mantenimiento del software IEEE Std 1074-1997 Standard for Developing Software Life Cycle Processes [IEEE, 1999b].</p>
            <p>El período de tiempo que comienza con la decisión de desarrollar un producto software y ﬁnaliza cuando se ha entregado éste. Este ciclo incluye, en general, una fase de requisitos, una fase de diseño, una fase de implantación, una fase de pruebas, y a veces, una fase de instalación y aceptación [AECC, 1986].</p>
            <div class="subheading mb-3">Etapas</div>
            <p>Desde un punto de vista general puede considerarse que el ciclo de vida de un software tiene tres etapas claramente diferenciadas:​</p>
            <ul>
              <li>Planiﬁcación: idearemos un planeamiento detallado que guíe la gestión del proyecto, temporal y económicamente.</li>
              <li>Implementación: acordaremos el conjunto de actividades que componen la realización del producto.</li>
              <li>Puesta en producción: nuestro proyecto entra en la etapa de deﬁnición, allí donde se lo presentamos al cliente o usuario ﬁnal, sabiendo que funciona correctamente y responde a los requerimientos solicitados en su momento. Esta etapa es muy importante no sólo por representar la aceptación o no del proyecto por parte del cliente o usuario ﬁnal sino por las múltiples diﬁcultades que suele presentar en la práctica, alargándose excesivamente y provocando costos no previstos.</li>
            </ul>
            <h3 class="mb-0">Ámbito general de: Requerimientos, análisis, diseño y pruebas de software</h3>
            <p>En cada una de las etapas de un modelo de ciclo de vida, se pueden establecer una serie de objetivos, tareas y actividades que lo caracterizan.</p>
            <div class="subheading mb-3">Expresión de necesidades</div>
            <p>Esta etapa tiene como objetivo el armado de un documento en el cual se reflejan los requerimientos y funcionalidades que ofrecerá al usuario el sistema a implementar (qué, y no cómo, se va a implementar).​</p>
            <div class="subheading mb-3">Especificaciones</div>
            <p>Formalizamos los requerimientos; el documento obtenido en la etapa anterior se tomará como punto de partida para esta etapa.​</p>
            <div class="subheading mb-3">Análisis</div>
            <p>Determinamos los elementos que intervienen en el sistema a desarrollar, su estructura, relaciones, evolución temporal, funcionalidades, tendremos una descripción clara de qué producto vamos a construir, qué funcionalidades aportará y qué comportamiento tendrá.​</p>
            <div class="subheading mb-3">Diseño</div>
            <p>ya sabemos qué hacer, ahora tenemos que determinar cómo debemos hacerlo (¿cómo debe ser construido el sistema en cuestion?; definimos en detalle entidades y relaciones de las bases de datos, seleccionamos el lenguaje que vamos a utilizar, el Sistema Gestor de Bases de Datos, etc.)</p>
            <div class="subheading mb-3">Implementación</div>
            <p>Empezamos a codificar algoritmos y estructuras de datos, de- finidos en las etapas anteriores, en el correspondiente lenguaje de programación o para un determinado sistema gestor de bases de datos. En muchos proyectos se pasa directamente a esta etapa; son proyectos muy arriesgados que adoptan un modelo de ciclo de vida de code & fix (codificar y corregir) donde se eliminan las etapas de especificaciones, análisis y diseño con la consiguiente pérdida de control sobre la gestión del proyecto.​</p>
            <div class="subheading mb-3">Debbuging</div>
            <p>El objetivo de esta etapa es garantizar que nuestro programa no contiene errores de diseño o codificación. En esta etapa no deseamos saber si nuestro programa realiza lo que solicitó el usuario, esa tarea le corresponde a la etapa de implementación. En ésta deseamos encontrar la mayor cantidad de errores. Todas los programas contienen errores: encontrarlos es cuestión de tiempo. Lo ideal es encontrar la mayoría, si no todos, en esta etapa. También se pueden agregar testeos de performance.​</p>
            <div class="subheading mb-3">Validación</div>
            <p>Eesta etapa tiene como objetivo la verificación de que el sistema desarrollado cumple con los requerimientos expresados inicialmente por el cliente y que han dado lugar al presente proyecto. En muchos proyectos las etapas de validación y debugging se realizan en paralelo por la estrecha relación que llevan. Sin embargo, tenemos que evitar la confusión: podemos realizarlos en paralelo, pero no como una única etapa.</p>
            <div class="subheading mb-3">Evolución</div>
            <p>En la mayoría de los proyectos se considera esta etapa como Mantenimiento y evolución, y se le asigna, no sólo el agregado de nuevas funcionalidades (evolución); sino la corrección de errores que surgen (mantenimiento). En la práctica esta denominación no es del todo errónea, ya que es posible que aun luego de una etapa de debugging y validación exhaustiva, se filtren errores.</p>
      </div>
    </section>

    <hr class="m-0">
    <section class="resume-section p-3 p-lg-5 d-flex align-items-center" id="themec">
      <div class="w-100">
        <h2 class="mb-5">2.3 Modelos de desarrollo: tradicionales vs alternativos</h2>
        <h3 class="mb-0">Concepto de modelo de Desarrollo de software </h3>
        <p>Los modelos de desarrollo de software son una representación abstracta de una manera en particular. Realmente no representa cómo se debe desarrollar el software, sino de un enfoque común. Puede ser modificado y adaptado de acuerdo a las necesidades del software en proceso de desarrollo. Hay varios modelos para perfilar el proceso de desarrollo, cada uno de las cuales cuenta con pros y contras. El proyecto debería escoger el más apropiado para sus necesidades. En ocasiones puede que una combinación de varios modelos sea apropiado.</p>
        <p>Los modelos de proceso de desarrollo de software incluyen los requisitos del sistema como entrada y un producto entregado como salida​.</p>
        <h3 class="mb-0">Modelos de Desarrollo de Software </h3>
        <div class="subheading mb-3">Modelo Cascada</div>
        <p>Las fases están identificadas por separado: ​</p>
          <ul>
          <li>El análisis  y definición de requerimientos​</li>          
          <li>Diseño del sistema y software.​</li>          
          <li>Pruebas de implementación de unidades​</li>          
          <li>Integración y pruebas del sistema ​</li>
          <li>Operación y mantenimiento</li>
          </ul>
          <p>El principal inconveniente del modelo de la cascada es la dificultad de acomodar el cambio después de que está en marcha el proceso. En principio, una fase tiene que ser completada antes de pasar a la siguiente fase.​</p>
         <div class="subheading mb-3">Modelo Prototipo</div>
        <p>Beneficios:</p>
        <ul>
          <li>El costo de atender las necesidades cambiantes de los clientes se reduce. ​<ul><li>La cantidad de análisis y la documentación que tiene que ser hecho de nuevo es mucho menor que la que se requiere con el modelo de cascada.</li></il></ul></li>
          <li>Es más fácil obtener retroalimentación de los clientes en el trabajo de desarrollo que se ha hecho.​<ul><li>Los clientes pueden hacer comentarios sobre las manifestaciones del software y ver cuánto se ha implementado. ​</li></ul></li>
          <li>Más rápida entrega y despliegue de software de utilidad para el cliente es posible. ​<ul><il>Los clientes pueden usar y obtener valor a partir del software anterior que es posible con un proceso de cascada.​</ul></li>
        </ul>
        <p>Problemas:</p>
        <ul>
          <li>El proceso no es visible.​<ul><il>Los gerentes necesitan entregas regulares para medir el progreso. Si se desarrollan rápidamente los sistemas, no es rentable para producir documentos que reflejen todas las versiones del sistema.​</li></ul></li> 
          <li>Estructura del sistema tiende a degradarse a medida que se añaden nuevos incrementos.<ul><li<>A menos tiempo y dinero que se gasta en la refactorización para mejorar el software, cambio regular tiende a corromper su estructura. La incorporación de nuevos cambios de software se vuelve cada vez más difícil y costoso. ​</li></ul> </li>
        </ul><li<>A menos tiempo y dinero que se gasta en la refactorización para mejorar el software, cambio regular tiende a corromper su estructura. La incorporación de nuevos cambios de software se vuelve cada vez más difícil y costoso. ​</li></ul>>
        <div class="subheading mb-3">Modelo Espiral</div>
        <p>En este modelo, el esfuerzo de desarrollo es iterativo. Tan pronto como uno completa un esfuerzo de desarrollo, otro comienza. Además, en cada desarrollo ejecutado, puedes seguir estos cuatros pasos.:</p>
          <ol>
          <li>Determinar qué quieres lograr. </li>
            <ul><li>Los objetivos de la parte del producto que está siendo elaborada (rendimientos, funcionalidad, adaptación al cambio, etc.). ​</li><li>Las alternativas principales de la implementación de esta porción del producto (usar el diseño A, usar el diseño B, reutilizar el módulo X de la aplicación Z, comprar a un proveedor externo, etc.). </li><li>Las restricciones impuestas para cada alternativa (costes, planificaciones, interfaces, etc.). </li></ul>
          <li>Determinar las rutas alternativas que puedes tomar para lograr estas metas. Por cada una, analizar los riesgos y resultados finales, y seleccionar la mejor. </li></li></ul>
            <ul><li>Evaluar las diferentes alternativas que se plantean teniendo en cuenta los objetivos a conseguir y las restricciones impuestas. Frecuentemente, este paso identifica las áreas de incertidumbre del proyecto con sus correspondientes riesgos.​</li><li>Si existen riesgos, lo siguiente es la formulación de una estrategia efectiva en coste (utilizando prototipos, simulación, bancos de prueba, cuestionario para los usuarios, modelización analítica o combinaciones de éstas y otras técnicas de resolución de riesgos) para resolver dichos riesgos.​</li></ul>
          <li>Seguir la alternativa seleccionada en el paso 2. 	</li>
            <ul><li>Tareas de la actividad propia y de prueba.​</li><li>Análisis de alternativas e identificación resolución de riesgos. </li><li>Dependiendo del resultado de la evaluación de los riesgos, se elige un modelo para el desarrollo, el que puede ser cualquiera de los otros existentes, como formal, evolutivo, cascada, etc.</li></ul>
          <li>Establecer qué tienes terminado</li>
            <ul><il>Revisar todo lo hecho, evaluándolo, y con ello decidir si se continúa con las fases siguientes y planificar la próxima actividad. </il></ul>
          </ol>
        <p>El Modelo Espiral mejora el Modelo de Cascada enfatizando la naturaleza iterativa del proceso de diseño. Eso introduce un ciclo de prototipo iterativo. En cada iteración, las nuevas expresiones que son obtenidas transformando otras dadas son examinadas para ver si representan progresos hacia el objetivo. </p>

        <h3 class="mb-0">Modelos ágiles: Scrum, Xp, Kanban, TDD(Test-Driven-Design)</h3>
        <div class="subheading mb-3">Modelo Scrum</div>
        <p>Scrum es un proceso en el que se aplican de manera regular un conjunto de buenas prácticas para trabajar colaborativamente, en equipo, y obtener el mejor resultado posible de un proyecto. Estas prácticas se apoyan unas a otras y su selección tiene origen en un estudio de la manera de trabajar de equipos altamente productivos.</p>
        <c><img src='img/scrum.gif'></c>
        <div class="subheading mb-3">Modelo XV</div>
        <p>La metodología XP o Programación Extrema es una metodología ágil y flexible utilizada para la gestión de proyectos. Extreme Programming se centra en potenciar las relaciones interpersonales del equipo de desarrollo como clave del éxito mediante el trabajo en equipo, el aprendizaje continuo y el buen clima de trabajo. Esta metodología pone el énfasis en la retroalimentación continua entre cliente y el equipo de desarrollo y es idónea para proyectos con requisitos imprecisos y muy cambiantes.</p>
        <c><img src='img/xp.jpg'></c>
        <div class="subheading mb-3">Modelo Kanban</div>
        <p>Kanban es una palabra japonesa que significa algo así como “tarjetas visuales” (kan significa visual, y ban tarjeta). Esta técnica se creó en Toyota, y se utiliza para controlar el avance del trabajo, en el contexto de una línea de producción. El Kanban está dentro de la estrategia Kaizen (te dejo un post sobre el Kaizen), es decir, la mejora continua y continuada.</p>
        <c><img src='img/kanban.png'></c>
        <div class="subheading mb-3">Modelo TDD (Test-Driven-Desing)</div>
        <p>Para escribir las pruebas generalmente se utilizan las pruebas unitarias (unit test en inglés). En primer lugar, se escribe una prueba y se verifica que las pruebas fallan. A continuación, se implementa el código que hace que la prueba pase satisfactoriamente y seguidamente se refactoriza el código escrito. El propósito del desarrollo guiado por pruebas es lograr un código limpio que funcione. La idea es que los requisitos sean traducidos a pruebas, de este modo, cuando las pruebas pasen se garantizará que el software cumple con los requisitos que se han establecido.</p>
        <p>Para que funcione el desarrollo guiado por pruebas, el sistema que se programa tiene que ser lo suficientemente flexible como para permitir que sea probado automáticamente. Cada prueba será suficientemente pequeña como para que permita determinar unívocamente si el código probado pasa o no la verificación que ésta le impone. El diseño se ve favorecido ya que se evita el indeseado "sobre diseño" de las aplicaciones y se logran interfaces más claras y un código más cohesivo.</p>
        <c><img src='img/tdd.gif'></c>
      </div>
    </section>
    <hr class="m-0">

    <div class="subheading mb-4"><a href="index.html">Volver al inicio</a></div>

  <!-- Bootstrap core JavaScript -->
  <script src="vendor/jquery/jquery.min.js"></script>
  <script src="vendor/bootstrap/js/bootstrap.bundle.min.js"></script>

  <!-- Plugin JavaScript -->
  <script src="vendor/jquery-easing/jquery.easing.min.js"></script>

  <!-- Custom scripts for this template -->
  <script src="js/resume.min.js"></script>

</body>

</html>
